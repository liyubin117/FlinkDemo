/* Simple1TokenManager.java */
/* Generated By:JavaCC: Do not edit this line. Simple1TokenManager.java */
package codegen.javacc.simple1;

/** Token Manager. */
public class Simple1TokenManager implements Simple1Constants {

    /** Debug output. */
    public static java.io.PrintStream debugStream = System.out;
    /** Set debug output. */
    public static void setDebugStream(java.io.PrintStream ds) {
        debugStream = ds;
    }

    private static int jjStopAtPos(int pos, int kind) {
        jjmatchedKind = kind;
        jjmatchedPos = pos;
        return pos + 1;
    }

    private static int jjMoveStringLiteralDfa0_0() {
        switch (curChar) {
            case 10:
                return jjStopAtPos(0, 1);
            case 13:
                return jjStopAtPos(0, 2);
            case 123:
                return jjStopAtPos(0, 3);
            case 125:
                return jjStopAtPos(0, 4);
            default:
                return 1;
        }
    }

    /** Token literal values. */
    public static final String[] jjstrLiteralImages = {
        "", "\12", "\15", "\173", "\175",
    };

    protected static Token jjFillToken() {
        final Token t;
        final String curTokenImage;
        final int beginLine;
        final int endLine;
        final int beginColumn;
        final int endColumn;
        String im = jjstrLiteralImages[jjmatchedKind];
        curTokenImage = (im == null) ? input_stream.GetImage() : im;
        beginLine = input_stream.getBeginLine();
        beginColumn = input_stream.getBeginColumn();
        endLine = input_stream.getEndLine();
        endColumn = input_stream.getEndColumn();
        t = Token.newToken(jjmatchedKind, curTokenImage);

        t.beginLine = beginLine;
        t.endLine = endLine;
        t.beginColumn = beginColumn;
        t.endColumn = endColumn;

        return t;
    }

    static final int[] jjnextStates = {0};

    static int curLexState = 0;
    static int defaultLexState = 0;
    static int jjnewStateCnt;
    static int jjround;
    static int jjmatchedPos;
    static int jjmatchedKind;

    /** Get the next Token. */
    public static Token getNextToken() {
        Token matchedToken;
        int curPos = 0;

        EOFLoop:
        for (; ; ) {
            try {
                curChar = input_stream.BeginToken();
            } catch (Exception e) {
                jjmatchedKind = 0;
                jjmatchedPos = -1;
                matchedToken = jjFillToken();
                return matchedToken;
            }

            jjmatchedKind = 0x7fffffff;
            jjmatchedPos = 0;
            curPos = jjMoveStringLiteralDfa0_0();
            if (jjmatchedKind != 0x7fffffff) {
                if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1);
                matchedToken = jjFillToken();
                return matchedToken;
            }
            int error_line = input_stream.getEndLine();
            int error_column = input_stream.getEndColumn();
            String error_after = null;
            boolean EOFSeen = false;
            try {
                input_stream.readChar();
                input_stream.backup(1);
            } catch (java.io.IOException e1) {
                EOFSeen = true;
                error_after = curPos <= 1 ? "" : input_stream.GetImage();
                if (curChar == '\n' || curChar == '\r') {
                    error_line++;
                    error_column = 0;
                } else error_column++;
            }
            if (!EOFSeen) {
                input_stream.backup(1);
                error_after = curPos <= 1 ? "" : input_stream.GetImage();
            }
            throw new TokenMgrError(
                    EOFSeen,
                    curLexState,
                    error_line,
                    error_column,
                    error_after,
                    curChar,
                    TokenMgrError.LEXICAL_ERROR);
        }
    }

    static void SkipLexicalActions(Token matchedToken) {
        switch (jjmatchedKind) {
            default:
                break;
        }
    }

    static void MoreLexicalActions() {
        jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
        switch (jjmatchedKind) {
            default:
                break;
        }
    }

    static void TokenLexicalActions(Token matchedToken) {
        switch (jjmatchedKind) {
            default:
                break;
        }
    }

    private static void jjCheckNAdd(int state) {
        if (jjrounds[state] != jjround) {
            jjstateSet[jjnewStateCnt++] = state;
            jjrounds[state] = jjround;
        }
    }

    private static void jjAddStates(int start, int end) {
        do {
            jjstateSet[jjnewStateCnt++] = jjnextStates[start];
        } while (start++ != end);
    }

    private static void jjCheckNAddTwoStates(int state1, int state2) {
        jjCheckNAdd(state1);
        jjCheckNAdd(state2);
    }

    /** Constructor. */
    public Simple1TokenManager(SimpleCharStream stream) {

        if (input_stream != null)
            throw new TokenMgrError(
                    "ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.",
                    TokenMgrError.STATIC_LEXER_ERROR);

        input_stream = stream;
    }

    /** Constructor. */
    public Simple1TokenManager(SimpleCharStream stream, int lexState) {
        ReInit(stream);
        SwitchTo(lexState);
    }

    /** Reinitialise parser. */
    public static void ReInit(SimpleCharStream stream) {

        jjmatchedPos = jjnewStateCnt = 0;
        curLexState = defaultLexState;
        input_stream = stream;
        ReInitRounds();
    }

    private static void ReInitRounds() {
        int i;
        jjround = 0x80000001;
        for (i = 0; i-- > 0; ) jjrounds[i] = 0x80000000;
    }

    /** Reinitialise parser. */
    public static void ReInit(SimpleCharStream stream, int lexState) {

        ReInit(stream);
        SwitchTo(lexState);
    }

    /** Switch to specified lex state. */
    public static void SwitchTo(int lexState) {
        if (lexState >= 1 || lexState < 0)
            throw new TokenMgrError(
                    "Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.",
                    TokenMgrError.INVALID_LEXICAL_STATE);
        else curLexState = lexState;
    }

    /** Lexer state names. */
    public static final String[] lexStateNames = {
        "DEFAULT",
    };

    /** Lex State array. */
    public static final int[] jjnewLexState = {
        -1, -1, -1, -1, -1,
    };

    static final long[] jjtoToken = {
        0x1fL,
    };
    static final long[] jjtoSkip = {
        0x0L,
    };
    static final long[] jjtoSpecial = {
        0x0L,
    };
    static final long[] jjtoMore = {
        0x0L,
    };
    protected static SimpleCharStream input_stream;

    private static final int[] jjrounds = new int[0];
    private static final int[] jjstateSet = new int[2 * 0];
    private static final StringBuilder jjimage = new StringBuilder();
    private static StringBuilder image = jjimage;
    private static int jjimageLen;
    private static int lengthOfMatch;
    protected static int curChar;
}
